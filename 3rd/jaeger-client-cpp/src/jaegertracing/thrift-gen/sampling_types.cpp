/**
 * Autogenerated by Thrift Compiler (0.9.2)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "sampling_types.h"

#include <algorithm>
#include <ostream>

#include <thrift/TToString.h>

namespace jaegertracing { namespace sampling_manager { namespace thrift {

int _kSamplingStrategyTypeValues[] = {
  SamplingStrategyType::PROBABILISTIC,
  SamplingStrategyType::RATE_LIMITING
};
const char* _kSamplingStrategyTypeNames[] = {
  "PROBABILISTIC",
  "RATE_LIMITING"
};
const std::map<int, const char*> _SamplingStrategyType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(2, _kSamplingStrategyTypeValues, _kSamplingStrategyTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));


ProbabilisticSamplingStrategy::~ProbabilisticSamplingStrategy() throw() {
}


void ProbabilisticSamplingStrategy::__set_samplingRate(const double val) {
  this->samplingRate = val;
}

const char* ProbabilisticSamplingStrategy::ascii_fingerprint = "66FFB53A2471384C03D9F21F6FACA58F";
const uint8_t ProbabilisticSamplingStrategy::binary_fingerprint[16] = {0x66,0xFF,0xB5,0x3A,0x24,0x71,0x38,0x4C,0x03,0xD9,0xF2,0x1F,0x6F,0xAC,0xA5,0x8F};

uint32_t ProbabilisticSamplingStrategy::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_samplingRate = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->samplingRate);
          isset_samplingRate = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_samplingRate)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t ProbabilisticSamplingStrategy::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("ProbabilisticSamplingStrategy");

  xfer += oprot->writeFieldBegin("samplingRate", ::apache::thrift::protocol::T_DOUBLE, 1);
  xfer += oprot->writeDouble(this->samplingRate);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(ProbabilisticSamplingStrategy &a, ProbabilisticSamplingStrategy &b) {
  using ::std::swap;
  swap(a.samplingRate, b.samplingRate);
}

ProbabilisticSamplingStrategy::ProbabilisticSamplingStrategy(const ProbabilisticSamplingStrategy& other0) {
  samplingRate = other0.samplingRate;
}
ProbabilisticSamplingStrategy& ProbabilisticSamplingStrategy::operator=(const ProbabilisticSamplingStrategy& other1) {
  samplingRate = other1.samplingRate;
  return *this;
}
std::ostream& operator<<(std::ostream& out, const ProbabilisticSamplingStrategy& obj) {
  using apache::thrift::to_string;
  out << "ProbabilisticSamplingStrategy(";
  out << "samplingRate=" << to_string(obj.samplingRate);
  out << ")";
  return out;
}


RateLimitingSamplingStrategy::~RateLimitingSamplingStrategy() throw() {
}


void RateLimitingSamplingStrategy::__set_maxTracesPerSecond(const int16_t val) {
  this->maxTracesPerSecond = val;
}

const char* RateLimitingSamplingStrategy::ascii_fingerprint = "565787C31CF2D774B532CB755189BF39";
const uint8_t RateLimitingSamplingStrategy::binary_fingerprint[16] = {0x56,0x57,0x87,0xC3,0x1C,0xF2,0xD7,0x74,0xB5,0x32,0xCB,0x75,0x51,0x89,0xBF,0x39};

uint32_t RateLimitingSamplingStrategy::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_maxTracesPerSecond = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->maxTracesPerSecond);
          isset_maxTracesPerSecond = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_maxTracesPerSecond)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t RateLimitingSamplingStrategy::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("RateLimitingSamplingStrategy");

  xfer += oprot->writeFieldBegin("maxTracesPerSecond", ::apache::thrift::protocol::T_I16, 1);
  xfer += oprot->writeI16(this->maxTracesPerSecond);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(RateLimitingSamplingStrategy &a, RateLimitingSamplingStrategy &b) {
  using ::std::swap;
  swap(a.maxTracesPerSecond, b.maxTracesPerSecond);
}

RateLimitingSamplingStrategy::RateLimitingSamplingStrategy(const RateLimitingSamplingStrategy& other2) {
  maxTracesPerSecond = other2.maxTracesPerSecond;
}
RateLimitingSamplingStrategy& RateLimitingSamplingStrategy::operator=(const RateLimitingSamplingStrategy& other3) {
  maxTracesPerSecond = other3.maxTracesPerSecond;
  return *this;
}
std::ostream& operator<<(std::ostream& out, const RateLimitingSamplingStrategy& obj) {
  using apache::thrift::to_string;
  out << "RateLimitingSamplingStrategy(";
  out << "maxTracesPerSecond=" << to_string(obj.maxTracesPerSecond);
  out << ")";
  return out;
}


OperationSamplingStrategy::~OperationSamplingStrategy() throw() {
}


void OperationSamplingStrategy::__set_operation(const std::string& val) {
  this->operation = val;
}

void OperationSamplingStrategy::__set_probabilisticSampling(const ProbabilisticSamplingStrategy& val) {
  this->probabilisticSampling = val;
}

const char* OperationSamplingStrategy::ascii_fingerprint = "70EB2FAA425B0221EA90513B35A43D26";
const uint8_t OperationSamplingStrategy::binary_fingerprint[16] = {0x70,0xEB,0x2F,0xAA,0x42,0x5B,0x02,0x21,0xEA,0x90,0x51,0x3B,0x35,0xA4,0x3D,0x26};

uint32_t OperationSamplingStrategy::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_operation = false;
  bool isset_probabilisticSampling = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->operation);
          isset_operation = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->probabilisticSampling.read(iprot);
          isset_probabilisticSampling = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_operation)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_probabilisticSampling)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t OperationSamplingStrategy::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("OperationSamplingStrategy");

  xfer += oprot->writeFieldBegin("operation", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->operation);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("probabilisticSampling", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->probabilisticSampling.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(OperationSamplingStrategy &a, OperationSamplingStrategy &b) {
  using ::std::swap;
  swap(a.operation, b.operation);
  swap(a.probabilisticSampling, b.probabilisticSampling);
}

OperationSamplingStrategy::OperationSamplingStrategy(const OperationSamplingStrategy& other4) {
  operation = other4.operation;
  probabilisticSampling = other4.probabilisticSampling;
}
OperationSamplingStrategy& OperationSamplingStrategy::operator=(const OperationSamplingStrategy& other5) {
  operation = other5.operation;
  probabilisticSampling = other5.probabilisticSampling;
  return *this;
}
std::ostream& operator<<(std::ostream& out, const OperationSamplingStrategy& obj) {
  using apache::thrift::to_string;
  out << "OperationSamplingStrategy(";
  out << "operation=" << to_string(obj.operation);
  out << ", " << "probabilisticSampling=" << to_string(obj.probabilisticSampling);
  out << ")";
  return out;
}


PerOperationSamplingStrategies::~PerOperationSamplingStrategies() throw() {
}


void PerOperationSamplingStrategies::__set_defaultSamplingProbability(const double val) {
  this->defaultSamplingProbability = val;
}

void PerOperationSamplingStrategies::__set_defaultLowerBoundTracesPerSecond(const double val) {
  this->defaultLowerBoundTracesPerSecond = val;
}

void PerOperationSamplingStrategies::__set_perOperationStrategies(const std::vector<OperationSamplingStrategy> & val) {
  this->perOperationStrategies = val;
}

void PerOperationSamplingStrategies::__set_defaultUpperBoundTracesPerSecond(const double val) {
  this->defaultUpperBoundTracesPerSecond = val;
__isset.defaultUpperBoundTracesPerSecond = true;
}

const char* PerOperationSamplingStrategies::ascii_fingerprint = "886A56A82DE9A0B1E1EDA82291918978";
const uint8_t PerOperationSamplingStrategies::binary_fingerprint[16] = {0x88,0x6A,0x56,0xA8,0x2D,0xE9,0xA0,0xB1,0xE1,0xED,0xA8,0x22,0x91,0x91,0x89,0x78};

uint32_t PerOperationSamplingStrategies::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_defaultSamplingProbability = false;
  bool isset_defaultLowerBoundTracesPerSecond = false;
  bool isset_perOperationStrategies = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->defaultSamplingProbability);
          isset_defaultSamplingProbability = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->defaultLowerBoundTracesPerSecond);
          isset_defaultLowerBoundTracesPerSecond = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->perOperationStrategies.clear();
            uint32_t _size6;
            ::apache::thrift::protocol::TType _etype9;
            xfer += iprot->readListBegin(_etype9, _size6);
            this->perOperationStrategies.resize(_size6);
            uint32_t _i10;
            for (_i10 = 0; _i10 < _size6; ++_i10)
            {
              xfer += this->perOperationStrategies[_i10].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_perOperationStrategies = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->defaultUpperBoundTracesPerSecond);
          this->__isset.defaultUpperBoundTracesPerSecond = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_defaultSamplingProbability)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_defaultLowerBoundTracesPerSecond)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_perOperationStrategies)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t PerOperationSamplingStrategies::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("PerOperationSamplingStrategies");

  xfer += oprot->writeFieldBegin("defaultSamplingProbability", ::apache::thrift::protocol::T_DOUBLE, 1);
  xfer += oprot->writeDouble(this->defaultSamplingProbability);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("defaultLowerBoundTracesPerSecond", ::apache::thrift::protocol::T_DOUBLE, 2);
  xfer += oprot->writeDouble(this->defaultLowerBoundTracesPerSecond);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("perOperationStrategies", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->perOperationStrategies.size()));
    std::vector<OperationSamplingStrategy> ::const_iterator _iter11;
    for (_iter11 = this->perOperationStrategies.begin(); _iter11 != this->perOperationStrategies.end(); ++_iter11)
    {
      xfer += (*_iter11).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.defaultUpperBoundTracesPerSecond) {
    xfer += oprot->writeFieldBegin("defaultUpperBoundTracesPerSecond", ::apache::thrift::protocol::T_DOUBLE, 4);
    xfer += oprot->writeDouble(this->defaultUpperBoundTracesPerSecond);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(PerOperationSamplingStrategies &a, PerOperationSamplingStrategies &b) {
  using ::std::swap;
  swap(a.defaultSamplingProbability, b.defaultSamplingProbability);
  swap(a.defaultLowerBoundTracesPerSecond, b.defaultLowerBoundTracesPerSecond);
  swap(a.perOperationStrategies, b.perOperationStrategies);
  swap(a.defaultUpperBoundTracesPerSecond, b.defaultUpperBoundTracesPerSecond);
  swap(a.__isset, b.__isset);
}

PerOperationSamplingStrategies::PerOperationSamplingStrategies(const PerOperationSamplingStrategies& other12) {
  defaultSamplingProbability = other12.defaultSamplingProbability;
  defaultLowerBoundTracesPerSecond = other12.defaultLowerBoundTracesPerSecond;
  perOperationStrategies = other12.perOperationStrategies;
  defaultUpperBoundTracesPerSecond = other12.defaultUpperBoundTracesPerSecond;
  __isset = other12.__isset;
}
PerOperationSamplingStrategies& PerOperationSamplingStrategies::operator=(const PerOperationSamplingStrategies& other13) {
  defaultSamplingProbability = other13.defaultSamplingProbability;
  defaultLowerBoundTracesPerSecond = other13.defaultLowerBoundTracesPerSecond;
  perOperationStrategies = other13.perOperationStrategies;
  defaultUpperBoundTracesPerSecond = other13.defaultUpperBoundTracesPerSecond;
  __isset = other13.__isset;
  return *this;
}
std::ostream& operator<<(std::ostream& out, const PerOperationSamplingStrategies& obj) {
  using apache::thrift::to_string;
  out << "PerOperationSamplingStrategies(";
  out << "defaultSamplingProbability=" << to_string(obj.defaultSamplingProbability);
  out << ", " << "defaultLowerBoundTracesPerSecond=" << to_string(obj.defaultLowerBoundTracesPerSecond);
  out << ", " << "perOperationStrategies=" << to_string(obj.perOperationStrategies);
  out << ", " << "defaultUpperBoundTracesPerSecond="; (obj.__isset.defaultUpperBoundTracesPerSecond ? (out << to_string(obj.defaultUpperBoundTracesPerSecond)) : (out << "<null>"));
  out << ")";
  return out;
}


SamplingStrategyResponse::~SamplingStrategyResponse() throw() {
}


void SamplingStrategyResponse::__set_strategyType(const SamplingStrategyType::type val) {
  this->strategyType = val;
}

void SamplingStrategyResponse::__set_probabilisticSampling(const ProbabilisticSamplingStrategy& val) {
  this->probabilisticSampling = val;
__isset.probabilisticSampling = true;
}

void SamplingStrategyResponse::__set_rateLimitingSampling(const RateLimitingSamplingStrategy& val) {
  this->rateLimitingSampling = val;
__isset.rateLimitingSampling = true;
}

void SamplingStrategyResponse::__set_operationSampling(const PerOperationSamplingStrategies& val) {
  this->operationSampling = val;
__isset.operationSampling = true;
}

const char* SamplingStrategyResponse::ascii_fingerprint = "D7657EDA3B19BAB27401BDBDD4E1103A";
const uint8_t SamplingStrategyResponse::binary_fingerprint[16] = {0xD7,0x65,0x7E,0xDA,0x3B,0x19,0xBA,0xB2,0x74,0x01,0xBD,0xBD,0xD4,0xE1,0x10,0x3A};

uint32_t SamplingStrategyResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_strategyType = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast14;
          xfer += iprot->readI32(ecast14);
          this->strategyType = (SamplingStrategyType::type)ecast14;
          isset_strategyType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->probabilisticSampling.read(iprot);
          this->__isset.probabilisticSampling = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->rateLimitingSampling.read(iprot);
          this->__isset.rateLimitingSampling = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->operationSampling.read(iprot);
          this->__isset.operationSampling = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_strategyType)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t SamplingStrategyResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("SamplingStrategyResponse");

  xfer += oprot->writeFieldBegin("strategyType", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->strategyType);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.probabilisticSampling) {
    xfer += oprot->writeFieldBegin("probabilisticSampling", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->probabilisticSampling.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.rateLimitingSampling) {
    xfer += oprot->writeFieldBegin("rateLimitingSampling", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->rateLimitingSampling.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.operationSampling) {
    xfer += oprot->writeFieldBegin("operationSampling", ::apache::thrift::protocol::T_STRUCT, 4);
    xfer += this->operationSampling.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(SamplingStrategyResponse &a, SamplingStrategyResponse &b) {
  using ::std::swap;
  swap(a.strategyType, b.strategyType);
  swap(a.probabilisticSampling, b.probabilisticSampling);
  swap(a.rateLimitingSampling, b.rateLimitingSampling);
  swap(a.operationSampling, b.operationSampling);
  swap(a.__isset, b.__isset);
}

SamplingStrategyResponse::SamplingStrategyResponse(const SamplingStrategyResponse& other15) {
  strategyType = other15.strategyType;
  probabilisticSampling = other15.probabilisticSampling;
  rateLimitingSampling = other15.rateLimitingSampling;
  operationSampling = other15.operationSampling;
  __isset = other15.__isset;
}
SamplingStrategyResponse& SamplingStrategyResponse::operator=(const SamplingStrategyResponse& other16) {
  strategyType = other16.strategyType;
  probabilisticSampling = other16.probabilisticSampling;
  rateLimitingSampling = other16.rateLimitingSampling;
  operationSampling = other16.operationSampling;
  __isset = other16.__isset;
  return *this;
}
std::ostream& operator<<(std::ostream& out, const SamplingStrategyResponse& obj) {
  using apache::thrift::to_string;
  out << "SamplingStrategyResponse(";
  out << "strategyType=" << to_string(obj.strategyType);
  out << ", " << "probabilisticSampling="; (obj.__isset.probabilisticSampling ? (out << to_string(obj.probabilisticSampling)) : (out << "<null>"));
  out << ", " << "rateLimitingSampling="; (obj.__isset.rateLimitingSampling ? (out << to_string(obj.rateLimitingSampling)) : (out << "<null>"));
  out << ", " << "operationSampling="; (obj.__isset.operationSampling ? (out << to_string(obj.operationSampling)) : (out << "<null>"));
  out << ")";
  return out;
}

}}} // namespace
