/**
 * Autogenerated by Thrift Compiler (0.9.2)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef jaeger_TYPES_H
#define jaeger_TYPES_H

#include <iosfwd>

#include <thrift/Thrift.h>
#include <thrift/TApplicationException.h>
#include <thrift/protocol/TProtocol.h>
#include <thrift/transport/TTransport.h>

#include <thrift/cxxfunctional.h>


namespace jaegertracing { namespace thrift {

struct TagType {
  enum type {
    STRING = 0,
    DOUBLE = 1,
    BOOL = 2,
    LONG = 3,
    BINARY = 4
  };
};

extern const std::map<int, const char*> _TagType_VALUES_TO_NAMES;

struct SpanRefType {
  enum type {
    CHILD_OF = 0,
    FOLLOWS_FROM = 1
  };
};

extern const std::map<int, const char*> _SpanRefType_VALUES_TO_NAMES;

class Tag;

class Log;

class SpanRef;

class Span;

class Process;

class Batch;

class BatchSubmitResponse;

typedef struct _Tag__isset {
  _Tag__isset() : vStr(false), vDouble(false), vBool(false), vLong(false), vBinary(false) {}
  bool vStr :1;
  bool vDouble :1;
  bool vBool :1;
  bool vLong :1;
  bool vBinary :1;
} _Tag__isset;

class Tag {
 public:

  static const char* ascii_fingerprint; // = "8582F6F2F042EBCA6A59AF229BC83A19";
  static const uint8_t binary_fingerprint[16]; // = {0x85,0x82,0xF6,0xF2,0xF0,0x42,0xEB,0xCA,0x6A,0x59,0xAF,0x22,0x9B,0xC8,0x3A,0x19};

  Tag(const Tag&);
  Tag& operator=(const Tag&);
  Tag() : key(), vType((TagType::type)0), vStr(), vDouble(0), vBool(0), vLong(0), vBinary() {
  }

  virtual ~Tag() throw();
  std::string key;
  TagType::type vType;
  std::string vStr;
  double vDouble;
  bool vBool;
  int64_t vLong;
  std::string vBinary;

  _Tag__isset __isset;

  void __set_key(const std::string& val);

  void __set_vType(const TagType::type val);

  void __set_vStr(const std::string& val);

  void __set_vDouble(const double val);

  void __set_vBool(const bool val);

  void __set_vLong(const int64_t val);

  void __set_vBinary(const std::string& val);

  bool operator == (const Tag & rhs) const
  {
    if (!(key == rhs.key))
      return false;
    if (!(vType == rhs.vType))
      return false;
    if (__isset.vStr != rhs.__isset.vStr)
      return false;
    else if (__isset.vStr && !(vStr == rhs.vStr))
      return false;
    if (__isset.vDouble != rhs.__isset.vDouble)
      return false;
    else if (__isset.vDouble && !(vDouble == rhs.vDouble))
      return false;
    if (__isset.vBool != rhs.__isset.vBool)
      return false;
    else if (__isset.vBool && !(vBool == rhs.vBool))
      return false;
    if (__isset.vLong != rhs.__isset.vLong)
      return false;
    else if (__isset.vLong && !(vLong == rhs.vLong))
      return false;
    if (__isset.vBinary != rhs.__isset.vBinary)
      return false;
    else if (__isset.vBinary && !(vBinary == rhs.vBinary))
      return false;
    return true;
  }
  bool operator != (const Tag &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Tag & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Tag& obj);
};

void swap(Tag &a, Tag &b);


class Log {
 public:

  static const char* ascii_fingerprint; // = "BF15A287717C8B21038FA44470407EA2";
  static const uint8_t binary_fingerprint[16]; // = {0xBF,0x15,0xA2,0x87,0x71,0x7C,0x8B,0x21,0x03,0x8F,0xA4,0x44,0x70,0x40,0x7E,0xA2};

  Log(const Log&);
  Log& operator=(const Log&);
  Log() : timestamp(0) {
  }

  virtual ~Log() throw();
  int64_t timestamp;
  std::vector<Tag>  fields;

  void __set_timestamp(const int64_t val);

  void __set_fields(const std::vector<Tag> & val);

  bool operator == (const Log & rhs) const
  {
    if (!(timestamp == rhs.timestamp))
      return false;
    if (!(fields == rhs.fields))
      return false;
    return true;
  }
  bool operator != (const Log &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Log & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Log& obj);
};

void swap(Log &a, Log &b);


class SpanRef {
 public:

  static const char* ascii_fingerprint; // = "0EE2406AF5BAD779BC70AC6569984DBA";
  static const uint8_t binary_fingerprint[16]; // = {0x0E,0xE2,0x40,0x6A,0xF5,0xBA,0xD7,0x79,0xBC,0x70,0xAC,0x65,0x69,0x98,0x4D,0xBA};

  SpanRef(const SpanRef&);
  SpanRef& operator=(const SpanRef&);
  SpanRef() : refType((SpanRefType::type)0), traceIdLow(0), traceIdHigh(0), spanId(0) {
  }

  virtual ~SpanRef() throw();
  SpanRefType::type refType;
  int64_t traceIdLow;
  int64_t traceIdHigh;
  int64_t spanId;

  void __set_refType(const SpanRefType::type val);

  void __set_traceIdLow(const int64_t val);

  void __set_traceIdHigh(const int64_t val);

  void __set_spanId(const int64_t val);

  bool operator == (const SpanRef & rhs) const
  {
    if (!(refType == rhs.refType))
      return false;
    if (!(traceIdLow == rhs.traceIdLow))
      return false;
    if (!(traceIdHigh == rhs.traceIdHigh))
      return false;
    if (!(spanId == rhs.spanId))
      return false;
    return true;
  }
  bool operator != (const SpanRef &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const SpanRef & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const SpanRef& obj);
};

void swap(SpanRef &a, SpanRef &b);

typedef struct _Span__isset {
  _Span__isset() : references(false), tags(false), logs(false) {}
  bool references :1;
  bool tags :1;
  bool logs :1;
} _Span__isset;

class Span {
 public:

  static const char* ascii_fingerprint; // = "AA54155ADAB6A4BBC542C4848D7A657E";
  static const uint8_t binary_fingerprint[16]; // = {0xAA,0x54,0x15,0x5A,0xDA,0xB6,0xA4,0xBB,0xC5,0x42,0xC4,0x84,0x8D,0x7A,0x65,0x7E};

  Span(const Span&);
  Span& operator=(const Span&);
  Span() : traceIdLow(0), traceIdHigh(0), spanId(0), parentSpanId(0), operationName(), flags(0), startTime(0), duration(0) {
  }

  virtual ~Span() throw();
  int64_t traceIdLow;
  int64_t traceIdHigh;
  int64_t spanId;
  int64_t parentSpanId;
  std::string operationName;
  std::vector<SpanRef>  references;
  int32_t flags;
  int64_t startTime;
  int64_t duration;
  std::vector<Tag>  tags;
  std::vector<Log>  logs;

  _Span__isset __isset;

  void __set_traceIdLow(const int64_t val);

  void __set_traceIdHigh(const int64_t val);

  void __set_spanId(const int64_t val);

  void __set_parentSpanId(const int64_t val);

  void __set_operationName(const std::string& val);

  void __set_references(const std::vector<SpanRef> & val);

  void __set_flags(const int32_t val);

  void __set_startTime(const int64_t val);

  void __set_duration(const int64_t val);

  void __set_tags(const std::vector<Tag> & val);

  void __set_logs(const std::vector<Log> & val);

  bool operator == (const Span & rhs) const
  {
    if (!(traceIdLow == rhs.traceIdLow))
      return false;
    if (!(traceIdHigh == rhs.traceIdHigh))
      return false;
    if (!(spanId == rhs.spanId))
      return false;
    if (!(parentSpanId == rhs.parentSpanId))
      return false;
    if (!(operationName == rhs.operationName))
      return false;
    if (__isset.references != rhs.__isset.references)
      return false;
    else if (__isset.references && !(references == rhs.references))
      return false;
    if (!(flags == rhs.flags))
      return false;
    if (!(startTime == rhs.startTime))
      return false;
    if (!(duration == rhs.duration))
      return false;
    if (__isset.tags != rhs.__isset.tags)
      return false;
    else if (__isset.tags && !(tags == rhs.tags))
      return false;
    if (__isset.logs != rhs.__isset.logs)
      return false;
    else if (__isset.logs && !(logs == rhs.logs))
      return false;
    return true;
  }
  bool operator != (const Span &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Span & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Span& obj);
};

void swap(Span &a, Span &b);

typedef struct _Process__isset {
  _Process__isset() : tags(false) {}
  bool tags :1;
} _Process__isset;

class Process {
 public:

  static const char* ascii_fingerprint; // = "4A5C2912BE6C88C79B33329AA651C11F";
  static const uint8_t binary_fingerprint[16]; // = {0x4A,0x5C,0x29,0x12,0xBE,0x6C,0x88,0xC7,0x9B,0x33,0x32,0x9A,0xA6,0x51,0xC1,0x1F};

  Process(const Process&);
  Process& operator=(const Process&);
  Process() : serviceName() {
  }

  virtual ~Process() throw();
  std::string serviceName;
  std::vector<Tag>  tags;

  _Process__isset __isset;

  void __set_serviceName(const std::string& val);

  void __set_tags(const std::vector<Tag> & val);

  bool operator == (const Process & rhs) const
  {
    if (!(serviceName == rhs.serviceName))
      return false;
    if (__isset.tags != rhs.__isset.tags)
      return false;
    else if (__isset.tags && !(tags == rhs.tags))
      return false;
    return true;
  }
  bool operator != (const Process &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Process & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Process& obj);
};

void swap(Process &a, Process &b);


class Batch {
 public:

  static const char* ascii_fingerprint; // = "245FA213AA72499F4AA5301FF5A1E955";
  static const uint8_t binary_fingerprint[16]; // = {0x24,0x5F,0xA2,0x13,0xAA,0x72,0x49,0x9F,0x4A,0xA5,0x30,0x1F,0xF5,0xA1,0xE9,0x55};

  Batch(const Batch&);
  Batch& operator=(const Batch&);
  Batch() {
  }

  virtual ~Batch() throw();
  Process process;
  std::vector<Span>  spans;

  void __set_process(const Process& val);

  void __set_spans(const std::vector<Span> & val);

  bool operator == (const Batch & rhs) const
  {
    if (!(process == rhs.process))
      return false;
    if (!(spans == rhs.spans))
      return false;
    return true;
  }
  bool operator != (const Batch &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Batch & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Batch& obj);
};

void swap(Batch &a, Batch &b);


class BatchSubmitResponse {
 public:

  static const char* ascii_fingerprint; // = "5892306F7B861249AE8E27C8ED619593";
  static const uint8_t binary_fingerprint[16]; // = {0x58,0x92,0x30,0x6F,0x7B,0x86,0x12,0x49,0xAE,0x8E,0x27,0xC8,0xED,0x61,0x95,0x93};

  BatchSubmitResponse(const BatchSubmitResponse&);
  BatchSubmitResponse& operator=(const BatchSubmitResponse&);
  BatchSubmitResponse() : ok(0) {
  }

  virtual ~BatchSubmitResponse() throw();
  bool ok;

  void __set_ok(const bool val);

  bool operator == (const BatchSubmitResponse & rhs) const
  {
    if (!(ok == rhs.ok))
      return false;
    return true;
  }
  bool operator != (const BatchSubmitResponse &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const BatchSubmitResponse & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const BatchSubmitResponse& obj);
};

void swap(BatchSubmitResponse &a, BatchSubmitResponse &b);

}} // namespace

#endif
